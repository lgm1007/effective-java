# 과도한 동기화는 피하라
### 외계인 메서드
* 응답 불가와 안전 실패를 유발할 수 있는 메서드
* 동기화된 영역에서 재정의할 수 있는 메서드 또는 클라이언트가 넘겨준 함수 객체 등을 동기화된 클래스 관점에서 칭하는 용어
* 동기화된 클래스는 외계인 메서드가 무슨 일을 할지 알지 못하며, 통제할 수도 없고, 외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나 교착상태에 빠지거나 데이터를 회손할 수도 있음
### 동기화의 정확성과 효율성 개선
* 외계인 메서드는 얼마나 오래 실행될지 알 수 없기 때문에 동기화 영역에서 호출된다면 그동안 다른 스레드는 보호된 자원을 사용하지 못하고 대기해야 함
* 따라서 열린 호출은 실패 방지 효괴 외에도 동시성 효율을 크게 개선시켜줌
  * 열린 호출(Open call) : 동기화 영역 바깥에서 호출되는 외계인 메서드
### 동기화의 기본 규칙
* 동기화 영역에서는 가능한 일을 적게 하는 것이 기본 규칙
* Lock을 얻고, 공유 데이터를 검사하고, 필요하면 수정하고, Lock을 놓음
* 오래 걸리는 작업이라면 동기화 영역 바깥으로 옮기는 방법 고려
### 동기화의 성능 개선
* 가변 클래스를 작성한다면 두 가지 선택지 중 하나를 따를 것
   1. 동기화를 전혀 고려하지 말고, 사용하는 클래스가 외부에서 알아서 동기화하도록 함
   2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만듦 (단, 클라이언트가 외부에서 전체에 Lock을 거는 것보다 효율성이 좋을 때만)
    * java 라이브러리 중 `java.util`은 첫 번째 방식을, `java.util.concurrent`는 두 번째 방식을 택함
    * 만약 선택하기 어렵다면 동기화하지 말고 "스레드 안전하지 않다." 라고 명시할 것
### 클래스 내부에서 동기화한다면
* 락 분할, 락 스트라이핑, 비차단 동시성 제어 등 다양한 기법으로 동시성을 높일 수 있음
* 락 분할(Lock Splitting)
  * 하나의 클래스에서 기능적으로 Lock을 분리해서 사용하는 것 (읽기 전용 Lock, 쓰기 전용 Lock)
* 락 스트라이핑(Lock Striping)
  * 자료구조 관점에서 한 자료구조 전체가 아닌 일부분에 락을 적용하는 것
* 비차단 동시성(Nonblocking concurrency)
  * 스레드가 작업이 완료될 때까지 다른 스레드를 대기시키지 않는 것
### 결론
* 교착 상태와 데이터 훼손을 피하려면 동기화 영역 내에서 외계인 메서드를 절대 호출하지 말자.
* 동기화 영역 내에서의 작업은 최소한으로 줄이자.
* 가변 클래스 설계 시에는 스스로 동기화가 필요한지에 대해 고민해보자.
* 합당한 이유가 있을 때만 내부에서 동기화하고, 동기화 여부를 문서에 명확히 명시하자.
---
[[Prev act >>]](../act1/README.md)  
[[Next act >>]](../act3/README.md)