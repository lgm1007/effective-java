# 변경 가능성을 최소화하라
### 불변 클래스
* 인스턴스 내부 값을 수정할 수 없는 클래스
* 객체가 파괴되는 순간까지 절대 달라지지 않음
  * String, 기본 타입의 박싱된 클래스, BigInteger, BigDecimal ...
* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽고 오류가 생길 여지가 적으며 훨씬 안전함
### 불변 클래스 5가지 규칙
1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
2. 클래스를 확장할 수 없도록 한다
   * 하위 클래스에서 부주의 혹은 나쁜 의도로 객체 상태를 변하게 만드는 사태를 막음
3. 모든 필드를 final로 선언한다
4. 모든 필드를 private로 선언한다
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다
   * 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 함
   * 접근자 메서드가 해당 객체를 그대로 반환해서도 안되며, 방어적 복사를 수행해야 함
```java
public final class Calculator {
    private final double a;
    private final double b;
    
    public Calculator(double a, double b) {
        this.a = a;
        this.b = b;
    }
    
    public Calculator plus(Calculator calculator) {
        // 자신의 필드를 수정하지 않고 새로운 객체를 생성함
        // (불변 클래스는 반드시 독립된 객체로 만듬)
        // 피연산자는 그대로 (함수형 프로그래밍)
        new Calculator(a + calculator.a, b + calculator.b);
    }
}
```
### 불변 복소수 클래스
* 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 함수형 프로그래밍이라고 함
* 절차적, 명령형 프로그래밍에서는 메서드에서 피연산자인 자신을 수정하여 상태가 변하게 됨
### 불변 객체
* 불변 객체는 단순하다
  * 생성 시점의 상태를 파괴될 때까지 간직함
* 모든 생성자가 클래스 불변식(class invariant)을 보장하면 영원히 불변으로 남는다
  * 반면, 가변 객체는 복잡한 상태에 놓일 수 있음
* 불변 객체는 근본적으로 스레드 안전하며 따로 동기화할 필요 없다
* 불변 객체는 안심하고 공유할 수 있다
  * 불변 객체에 대해서는 어떤 스레드도 다른 스레드에 영향을 줄 수 없기 때문
* 가장 쉬운 불변 클래스의 인스턴스 재사용은 자주 쓰이는 값들을 상수(public static final)로 제공하는 것이다.
* 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다.
* 불변 객체는 방어적 복사가 필요 없다
  * 복사해도 원본과 똑같으니 복사 자체가 의미 없음
* 불변 객체는 그 자체로 실패 원자성을 제공한다
  * 실패 원자성(failure atomicity): 메서드에서 예외가 발생한 후에도 그 객체는 메서드 호출 전과 같은 유효한 상태여야 한다는 성질
#### 불변 객체의 단점
* 불변 객체는 값이 다르다면 반드시 독립된 객체로 만들어야 한다
* 위에 대응하는 방안
  1. 다단계 연산(multistep operation)들을 예측하여 기본 기능으로 제공하는 방법
  2. 예측 불가능할 경우 가변 동반 클래스를 public으로 제공하는 것
     * StringBuilder, StringBuffer ...
### 생성자 대신 정적 팩터리를 사용한 불변 클래스
* 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야 함
* 가장 쉬운 방법은 final 클래스로 선언하기
* 또는, 생성자를 private로 선언하고 정적 팩터리를 제공할 수도 있음
---
[[Prev act >>]](../act2/README.md)  
[[Next act >>]](../act4/README.md)