# 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
### 마커 인터페이스
* 아무 메서드도 담고 있지 않고, 자신을 구현하는 클래스가 특정 속성을 가진다는 것만 표시해주는 인터페이스
* 예) `Serializable` 인터페이스
* 구현해야 할 메서드도 없는 인터페이스를 왜 작성할까?
    1. 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 어노테이션은 그렇지 않음
    2. 마커 인터페이스는 적용 대상을 더 정밀하게 지정할 수 있음
       * 적용 대상(`@Target`)을 `ElementType.TYPE`으로 선언한 어노테이션은 모든 타입에 달 수 있음, 즉 부착할 수 있는 타입을 세밀하게 제한하지는 못함
* 반대로 마커 어노테이션이 마커 인터페이스보다 나은 점
  * 거대한 어노테이션 시스템의 지원을 받음
  * 어노테이션을 주로 사용하는 프레임워크에서는 마커 어노테이션을 사용하는 편이 좋을 것
* `Set` 인터페이스도 일종의 제약 있는 마커 인터페이스로 볼 수 있음
  * `Set`은 `Collection`의 하위 타입에만 적용할 수 있으며, `Collection`이 정의한 메서드 외에는 새로 추가한 것이 없음
  * add, equals, hashCode 등 `Collection`의 메서드 몇 개의 규약을 수정한 부분은 있음
### 마커 어노테이션
* 멤버를 포함하지 않으며 데이터로 구성되지 않는 어노테이션
* 단지 어노테이션의 선언을 표시하는 것을 목적으로 함
* 예) `@Override`
### 결론
* 마커 인터페이스와 마커 어노테이션은 각자 쓰임이 있다.
* 새로 추가하는 메서드 없이 단지 타입의 정의가 목적이라면 마커 인터페이스를 사용하자.
* 클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나 어노테이션을 주로 사용하는 프레임워크에서는 마커 어노테이션을 사용하자.
* 적용 대상이 `ElementType.TYPE`인 마커 어노테이션을 작성하고 있다면 정말 어노테이션으로 구현하는 게 옳은지, 마커 인터페이스가 낫지 않은지 생각해볼 필요가 있다.
---
[[Prev act >>]](../act7/README.md)