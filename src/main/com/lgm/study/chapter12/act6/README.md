# 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
* Serializable을 구현하기로 한 순간부터 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 됨
  * 버그와 보안 문제가 일어날 가능성이 커질 수 있음
* 위 위험을 줄어주는 기법이 **직렬화 프록시 패턴**
### 직렬화 프록시 패턴
* 가짜 바이트 스트림 공격과 내부 필드 탈취 공격을 프록시 수준에서 차단해주는 패턴
* 구조
    1. 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 private static으로 선언
       * 이 중첩 클래스가 바깥 클래스의 직렬화 프록시
    2. 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받음
    3. 생성자는 단순히 인수로 넘어온 인스턴스를 복사함
    4. 바깥 클래스와 직렬화 프록시 모두 Serializable을 선언함
### 직렬화 프록시 패턴의 장점
1. 가짜 바이트 스트림 공격이나 내부 필드 탈취 공격을 프록시 수준에서 차단
2. 필드를 final로 선언해도 되므로 직렬화 시스템에서 진짜 불변을 만들 수 있음
3. 역직렬화 시 유효성 검사를 수행하지 않아도 됨
4. 역직렬화한 인스턴스와 원래의 직렬화된 클래스가 달라도 정상적으로 동작함
### 직렬화 프록시 패턴의 한계점
1. 클라이언트가 마음대로 확장할 수 있는 클래스에는 적용할 수 없음
2. 객체 그래프에 순환이 있는 클래스에 적용할 수 없음
3. 방어적 복사보다 느림
* 위와 같은 객체의 메서드를 직렬화 프록시 readResolve 안에서 호출하면 ClassCastException 가 발생함
  * 실제 객체는 아직 만들어지지 않았기 때문
### 핵심 정리
* 제 3자가 확장할 수 없는 클래스라면 직렬화 프록시 패턴을 사용하자.
---
[[Prev act >>]](../act5/README.md)  