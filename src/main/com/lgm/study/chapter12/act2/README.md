# Serializable을 구현할지는 신중히 결정하라
### Serializable
* 어떤 클래스의 인스턴스를 직렬화할 수 있게 하기 위한 인터페이스
* Serializable을 구현하면 릴리즈한 뒤엔 수정하기 어려움
* 기본 직렬화 형태에선 클래스의 `private`와 `package-private` 인스턴스 필드까지 API로 공개하는 꼴
  * 캡슐화가 깨짐
### 직렬화의 문제점
1. 모든 직렬화 클래스는 고유 식별 번호를 부여받음
2. 버그와 보안 구멍이 생길 위험이 높아짐
3. 해당 클래스의 신버전을 릴리즈할 때 테스트할 것이 늘어남
* **Serializable 구현 여부는 가볍게 결정할 사항이 아니다.**
### 상속 또는 확장 X
* 상속용으로 설계된 클래스는 대부분 Serializable을 구현해선 안 됨
* 인터페이스도 대부분 Serializable을 확장해선 안 됨
* 위 규칙을 어겨야 할 상황
  * Serializable을 구현한 클래스만 지원하는 프레임워크를 사용해야 하는 상황
  * 예) `Throwable`, `Component`
### finalizer 재정의 금지
* 인스턴스 필드 값 중 불변식을 보장해야 할 값이 있으면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 함
* 이렇지 않으면 finalizer 공격을 받을 수 있음
### 내부 클래스 (inner class)
* 내부 클래스에는 바깥 인스턴스의 참조와 유효 범위 내 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가됨
* 해당 필드들이 클래스 정의에 어떻게 추가되었는지 정의되지 않았기 때문에 기본 직렬화 형태가 분명하지 않아 이용 불가능함
* 단 정적 멤버 클래스는 예외
  * static 멤버 클래스 : Serializable 구현 가능
  * 익명 내부 클래스, 지역 내부 클래스 : Serializable 구현 불가능
---
[[Prev act >>]](../act1/README.md)  
[[Next act >>]](../act3/README.md)