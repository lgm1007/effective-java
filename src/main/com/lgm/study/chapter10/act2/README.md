# 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타입 예외를 사용하라
### 검사 예외
* 호출하는 쪽에서 복구 가능하다 여겨지는 상황이라면 검사 예외를 사용할 것
  * 검사 예외를 던질 시 **호출자가 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 됨**
  * 예) 메서드 호출 시 강제적으로 `try-catch` 혹은 `throw`해야 하는 경우
* 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생
  * 따라서, 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요
### 비검사 예외
* 비검사 throwable은 두 가지
  * 런타임 예외
  * 에러
#### 런타임 예외
* 프로그래밍 오류를 나타낼 때는 **런타임 예외**를 사용할 것
* 대부분 **클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못할 경우** 런타임 예외 발생
* **복구가 가능하다고 판단되면 검사 예외를, 그렇지 않으면 런타임 예외, 확신이 어렵다면 비검사 예외를 선택할 것**
#### 에러
* 에러는 보통 JVM이 자원부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없을 때 사용
* 자바 언어의 널리 퍼진 규약으로 Error 클래스를 상속해 하위 클래스를 만드는 일을 자제하는 것이 좋음
  * 즉, 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 함
  * Error는 상속하지 말아야 할 뿐 아니라, throw문을 직접 던지는 일도 없어야 함
* 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰임
  * 그러나, throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않음
  * 이는 JVM이나 릴리즈에 따라 포맷이 달라질 수 있다는 의미
### 결론
* 복구할 수 있는 상황이라면 검사 예외
* 프로그래밍 오류라면 런타임 예외
* 확실하지 않다면 비검사 예외
* 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지 말 것
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하라.
---
[[Prev act >>]](../act1/README.md)  
[[Next act >>]](../act3/README.md)